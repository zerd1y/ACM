## 10.21
- 1.思维题：顺推倒推/顺算逆算/from to->to from(ABC376B)
## 10.22
### 贪心题：
- **1.** 很可能有一种准确的排序方法/算式
- **2.** 首尾记得处理
- **3.** 小技巧：
- ①递推式：a[i]、a[i+1]
- ② 联想：数轴-线段排序（左/右端点）-线段覆盖
## 10.23
- **1.** 轮盘式的轮转题：加一句 %n 防止溢出
```cpp
now=(now+n-y)%n;
now=(now+y)%n;
```
## 10.28
- **1.** **前缀和 / 更新** 的思想
- 第一个数为一个有效序列
- 如果一个数加上上一个有效序列得到的结果比这个数大，那么该数也属于这个有效序列。
- 如果一个数加上上一个有效序列得到的结果比这个数小，那么这个数单独成为一个新的有效序列
- 在执行上述处理的过程中实时更新当前有效序列的所有元素之和并取最大值。
```cpp
P1115 最大子段和:

#include<bits/stdc++.h>
using namespace std;
int n,a[200020],b[200020],i,ans=-2147483647;
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>a[i];
		if (i==1) b[i]=a[i];
		else b[i]=max(a[i],b[i-1]+a[i]);
		ans=max(ans,b[i]);
	}
	cout<<ans;
	return 0;
}
```
- **2.** **取模**
- （1）(a + b) % p = (a % p + b % p) % p 
- （2）(a - b) % p = (a % p - b % p ) % p
- （3）(a * b) % p = (a % p * b % p) % p
- **3. 快速幂：**
```cpp
int quickPower(int a, int b)//是求a的b次方
{
	int ans = 1, base = a;//ans为答案，base为a^(2^n)
	while(b > 0)//b是一个变化的二进制数，如果还没有用完
    {
		if(b & 1)//&是位运算，b&1表示b在二进制下最后一位是不是1，如果是：
			ans *= base;//把ans乘上对应的a^(2^n)
		
        base *= base;//base自乘，由a^(2^n)变成a^(2^(n+1))
		b >>= 1;//位运算，b右移一位，如101变成10（把最右边的1移掉了），10010变成1001。现在b在二进制下最后一位是刚刚的倒数第二位。结合上面b & 1食用更佳
	}
	return ans;
}
```
```cpp
快速幂＋取模
while(b > 0)
    {
		if(b & 1)
        {
			ans *= base;
            ans %= m;
    	}
		
        base *= base;
        base %= m;
		b >>= 1;
	}
```

## 10.30
- **1.bx += 2; by += 2; mx += 2; my += 2;
    //坐标+2以防越界**
## 11.16
- **画图：放在矩阵中画（二维数组）**
- **递归画图：**
```cpp
void f(int x, int y, int n) {
}
```
- x,y为坐标  n为大小（单位图形量）
