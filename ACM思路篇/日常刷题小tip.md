## 10.21
- 1.思维题：顺推倒推/顺算逆算/from to->to from(ABC376B)
## 10.22
### 贪心题：
- **1.** 很可能有一种准确的排序方法/算式
- **2.** 首尾记得处理
- **3.** 小技巧：
- ①递推式：a[i]、a[i+1]
- ② 联想：数轴-线段排序（左/右端点）-线段覆盖
## 10.23
- **1.** 轮盘式的轮转题：加一句 %n 防止溢出
```cpp
now=(now+n-y)%n;
now=(now+y)%n;
```
## 10.28
- **1.** **前缀和 / 更新** 的思想
- 第一个数为一个有效序列
- 如果一个数加上上一个有效序列得到的结果比这个数大，那么该数也属于这个有效序列。
- 如果一个数加上上一个有效序列得到的结果比这个数小，那么这个数单独成为一个新的有效序列
- 在执行上述处理的过程中实时更新当前有效序列的所有元素之和并取最大值。
```cpp
P1115 最大子段和:

#include<bits/stdc++.h>
using namespace std;
int n,a[200020],b[200020],i,ans=-2147483647;
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>a[i];
		if (i==1) b[i]=a[i];
		else b[i]=max(a[i],b[i-1]+a[i]);
		ans=max(ans,b[i]);
	}
	cout<<ans;
	return 0;
}
```
